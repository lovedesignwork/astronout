import { createClient, createAdminClient } from '@/lib/supabase/server';
import { generateBookingReference, generateSecureToken } from '@/lib/utils';
import type {
  Booking,
  BookingItem,
  BookingWithItems,
  CreateBookingPayload,
  BookingStatus,
} from '@/types';

/**
 * Create a new booking with items
 */
export async function createBooking(
  payload: CreateBookingPayload
): Promise<{ booking: Booking; error: string | null }> {
  const supabase = await createClient();

  const voucherToken = generateSecureToken();

  // Calculate totals from selection
  const { tour, upsells, grandTotalRetail, grandTotalNet, currency } = payload.selection;

  // Create booking record
  // Note: reference will be auto-generated by database trigger (AST-237551, AST-237552, etc.)
  const { data: booking, error: bookingError } = await supabase
    .from('bookings')
    .insert({
      tour_id: payload.tourId,
      availability_id: payload.availabilityId || null,
      booking_date: payload.bookingDate,
      customer_name: payload.customerName,
      customer_email: payload.customerEmail,
      customer_phone: payload.customerPhone || null,
      customer_nationality: payload.customerNationality || null,
      total_retail: grandTotalRetail,
      total_net: grandTotalNet,
      currency,
      status: 'pending_payment' as BookingStatus,
      language: payload.language,
      voucher_token: voucherToken,
      notes: payload.notes || null,
    })
    .select()
    .single();

  if (bookingError || !booking) {
    console.error('Error creating booking:', bookingError);
    return { booking: null as unknown as Booking, error: 'Failed to create booking' };
  }

  // Create booking items
  const items: Partial<BookingItem>[] = [];

  // Add main tour item
  items.push({
    booking_id: booking.id,
    item_type: 'tour',
    item_id: payload.tourId,
    item_name: tour.tourName,
    quantity: tour.pax.total,
    retail_price_snapshot: tour.totalRetail / tour.pax.total,
    net_price_snapshot: tour.totalNet / tour.pax.total,
    subtotal_retail: tour.totalRetail,
    subtotal_net: tour.totalNet,
    metadata: {
      date: tour.date,
      time: tour.time,
      pax: tour.pax,
      seat: tour.seat,
      priceBreakdown: tour.priceBreakdown,
    },
  });

  // Add upsell items
  for (const upsell of upsells) {
    items.push({
      booking_id: booking.id,
      item_type: 'upsell',
      item_id: upsell.upsellId,
      item_name: upsell.title,
      quantity: upsell.quantity,
      retail_price_snapshot: upsell.unitRetailPrice,
      net_price_snapshot: upsell.unitNetPrice,
      subtotal_retail: upsell.totalRetail,
      subtotal_net: upsell.totalNet,
      metadata: {
        pricingType: upsell.pricingType,
      },
    });
  }

  const { error: itemsError } = await supabase
    .from('booking_items')
    .insert(items);

  if (itemsError) {
    console.error('Error creating booking items:', itemsError);
    // Don't fail the whole booking, items can be fixed later
  }

  return { booking, error: null };
}

/**
 * Get booking by ID (admin only)
 */
export async function getBookingById(
  bookingId: string
): Promise<BookingWithItems | null> {
  const supabase = await createAdminClient();

  const { data: booking, error } = await supabase
    .from('bookings')
    .select(`
      *,
      items:booking_items (*),
      tour:tours (*)
    `)
    .eq('id', bookingId)
    .single();

  if (error || !booking) {
    return null;
  }

  return booking as BookingWithItems;
}

/**
 * Get booking by reference and voucher token (public voucher access)
 */
export async function getBookingByVoucherToken(
  bookingId: string,
  token: string
): Promise<BookingWithItems | null> {
  const supabase = await createClient();

  // Use service role to bypass RLS for voucher access
  const adminSupabase = await createAdminClient();

  const { data: booking, error } = await adminSupabase
    .from('bookings')
    .select(`
      *,
      items:booking_items (*),
      tour:tours (slug)
    `)
    .eq('id', bookingId)
    .eq('voucher_token', token)
    .single();

  if (error || !booking) {
    return null;
  }

  return booking as BookingWithItems;
}

/**
 * Update booking status
 */
export async function updateBookingStatus(
  bookingId: string,
  status: BookingStatus
): Promise<{ success: boolean; error: string | null }> {
  const supabase = await createAdminClient();

  const { error } = await supabase
    .from('bookings')
    .update({ status })
    .eq('id', bookingId);

  if (error) {
    return { success: false, error: error.message };
  }

  return { success: true, error: null };
}

/**
 * Update availability after booking confirmation
 */
export async function incrementBookedCount(
  availabilityId: string,
  count: number
): Promise<boolean> {
  const supabase = await createAdminClient();

  const { error } = await supabase.rpc('increment_booked_count', {
    availability_id: availabilityId,
    increment_by: count,
  });

  return !error;
}


